[[elements-lang]]
== Java Language Extensions

This chapter covers Java language extensions and features provided by _Elements_.

[[elements-lang-dsl]]
=== Domain Specific Languages (DSL)

_Elements_ provides 5 different domain-specific languages (DSL) that you can use to write concise, yet expressive code.
By statically importing the DSL language operators declared and defined in the `org.cp.elements.lang.LangExtensions`
class, you can immediately write much more powerful code in fewer lines.

[[elements-lang-dsl-assertThat]]
==== `assertThat` operator

The `assertThat` operator and DSL enables developers to make assertions about the state of his or her running programs.

For instance, a developer can assert that an object reference is not `null`.

.AssertThat Not Null
[source,java]
[subs="verbatim,attributes"]
----
assertThat(objectReference).isNotNull();
----

The `assertThat` operator and DSL provided by _Elements_ is very similar to https://assertj.github.io/doc/[AssertJ],
and was partly inspired by AssertJ. However, Elements `assertThat` operator and DSL focuses on the most common
and useful assertions and more refined expressions.

NOTE: For complete assertion coverage, we recommend developers use AssertJ.

Other common assertions include, but are not limited to:

* `isAssignableTo(:Class<?>)` | `isInstanceOf(:Class<?>)`
* `isComparableTo(:Coparable<?>)` | `isNotComparableTo(:Comparable<?>)`
* `isEqualsTo(..)` | `isNotEqualTo(..)`
* `isGreaterThan(..)`
* `isGreaterThanAndLessThan(..)`
* `isGreaterThanAndLessThanEqualTo(..)`
* `isGreaterThanEqualTo(..)`
* `isGreaterThanEqualToAndLessThan(..)`
* `isGreaterThanEqualToAndLessThanEqualTo(..)`
* `hasText(..)`
* `holdsLock(..)`
* `isNotBlank()`
* `isNotEmpty()` For: Arrays, Collections, Iterables, Maps and Strings
* `isFalse()` | `isTrue()`
* `isLessThan(..)`
* `isLessThanOrGreaterThan(..)`
* `isLessThanOrGreaterThanEqualTo(..)`
* `isLessThanEqualTo(..)`
* `isLessThanEqualToOrGreaterThan(..)`
* `isLessThanEqualToOrGreaterThanEqualTo(..)`
* `isNull()` | `isNotNull()`
* `isSameAs(:Object)` | `isNotSameAs(:Object)`
* `isValid(:Predicate)`

In addition to the assertions listed above, the `assertThat` operator supports strongly-typed assertions
making it possible to do:

.Type-specific assertions
[source,java]
[subs="verbatim,attributes"]
----
Object user = //...

assertThat(user).isInstanceOf(User.class)
  .as(User.class)
  .isEqualTo(User.as("jonDoe"));
----

The assertion above is useful when the incoming object type is not known in advance. More specifically, developers
may assert specific properties of a typed object as well:

.Assertion extraction (mapping)
[source,java]
[subs="verbatim,attributes"]
----
Object user = //...

assertThat(user).isInstanceOf(User.class)
  .as(User.class)
  .map(User::getName)
  .isEqualTo("jonDoe");
----

Developers may customize the Exception message thrown from the assertion as well as throw custom Exceptions
when necessary:

.Custom Exception message
[source,java]
[subs="verbatim,attributes"]
----
Object user = //...

assertThat(user).isInstanceOf(User.class).as(User.class)
  .describedAs("Expected user of type [%s]", User.class.getName())
  .map(User::getName)
  .isEqualTo("jonDoe");
----

.Custom Exception
[source,java]
[subs="verbatim,attributes"]
----
Object user = //...

assertThat(user).isInstanceOf(User.class).as(User.class)
  .throwing(new UnauthorizedUser("User " + user + " is not authorized"))
  .map(User::getRole)
  .isEqualTo("Admin");
----

An assertion may be easily negated using `not()`, such as:

.Assertion negation
[source,java]
[subs="verbatim,attributes"]
----
assertThat(object).not().holdsLock();
----

Certain assertions conveniently provide named negation variants, such as:
`isNotEqualTo(:Object)` or `isNotSameAs(:Object)`.

Unlike Java assertions, Elements assertions can be enabled or disabled using a complex expression, expressed with a
`Condition` implementation.

.Conditional assertions
[source,java]
[subs="verbatim,attributes"]
----
Condition enabled = // ...

assertThat(object).when(enabled).isValid(:Predicate)
----

A `Condition` can be reused across assertions. Individual, or grouped assertions can each have custom `Conditions`
of your choosing.

The `assertThat(..)` DSL operator provides many more capabilities out-of-the-box.

[[elements-lang-dsl-assertThat-exceptions]]
==== `assertThat` operator for Exceptions

The Elements `org.cp.elements.lang.ThrowableAssertions` class provides assertions for common Exceptions
thrown by application code:

* `assertThatArrayIndexOutOfBoundsException()`
* `assertThatIllegalArgumentException()`
* `assertThatIllegalStateException()`
* `assertThatIndexOutOfBoundsException()`
* `assertThatInterruptedException()`
* `assertThatNullPointerException()`
* `assertThatRuntimeException()`
* `assertThatSecurityException()`
* `assertThatUnsupportedOperationException()`

If your asserted Exception is not conveniently provided by a DSL, you can generically use:

* `assertThatThrowableOfType(:Class<? extends Throwable>)`

Even though Exception assertions were inspired by AssertJ as well, Elements Exception assertions enable assertion
chaining in the event that the application code throws a chained Exception. This enables developers to write
more expression Exception assertions:

.Chained Exception assertions
[source,java]
[subs="verbatim,attributes"]
----
assesrtThatThrowableOfType(UnauthroizedUserException.class)
  .isThrownBy(args -> applicationCodeThrowingSecurityExceptions(unauthorizedUser))
  .havingMessage("User [%s] is not authorized", unauthorizedUser)
  .causedBy(SecurityException.class)
  .havingMessage("Security access exception occurred")
  .withNoCause();
----

When the `causeBy(:Class<? extends Throwable>)` method is called, it switches the assertion context to
the targeted Exception.

[[elements-lang-dsl-from]]
==== `from` operator

The `from` operator and DSL enables a developer to _cast_ or _convert_ from one type of object
to another type of object.

.Casting
[source,java]
[subs="verbatim,attributes"]
----
var numericObjectReference = 2;

Integer two = from(numericObjectReference).castTo(Integer.class);
----

.Converting
[source,java]
[subs="verbatim,attributes"]
----
Double number = from("123.45").convertTo(Double.class);
----

Under-the-hood, the `from` operator uses _Elements_ powerful Conversion library to perform the conversion.

Additionally, given a `java.util.function.Function`, developers may map an `Object` from 1 type to another:

.Mapping
[source,java]
[subs="verbatim,attributes"]
----
User jonDoe = from("jonDoe").mapTo(username -> User.as(username));
----

[[elements-lang-dsl-given]]
==== `given` operator

The `given` operator and DSL enables developers to declare "_expectations_" for an object,
satisfying certain conditions or requirements.

.Given
[source,java]
[subs="verbatim,attributes"]
----
User jonDoe = ...;

boolean result = given(jonDoe)
  .expectThat(jonDoe::isAuthenticated)
  .expectThat(jonDoe::isActive)
  .thenGiven(jonDoe::getGroups)
  .expectThat(jonDoeGroups -> jonDoeGroups.contains(Group.AUTHORIZED_USER))
  .result();
----

Alternatively, you can throw on a failed expectation.

.Given
[source,java]
[subs="verbatim,attributes"]
----
User jonDoe = ...;

given(jonDoe)
  .expectThat(jonDoe::isActive)
  .expectThat(jonDoe::isAuthenticated)
  .throwOnFailedExpectations()
  .thenGiven(jonDoe::getGroups)
  .expectThat(jonDoeGroups -> jonDoeGroups.contains(Group.AUTHORIZED_USER))
  .throwOnFailedExpectations();
----

`given` is a null-safe operator.

[[elements-lang-dsl-is]]
==== `is` operator

The `is` operator and DSL enables developers to perform conditional tests on an object or expression.

.Is
[source,java]
[subs="verbatim,attributes"]
----
boolean result = is(objectReference).notNull();
----

For more complex conditional tests, you can pass in a `java.util.function.Predicate`:

.Is using Predicate
[source,java]
[subs="verbatim,attributes"]
----
boolean result = is(objectReference).valid(:Prediate);
----

It is easy to negate the expression using the `not()` function:

.Is Not
[source,java]
[subs="verbatim,attributes"]
----
boolean result = is(objectReference).not().sameAs(otherObjectReference);
----

Conveniently, the `is` operator offers shortcuts for some of the negated conditional expressions:

.Is Not
[source,java]
[subs="verbatim,attributes"]
----
boolean result = is(objectReference).notSameAs(otherObjectReference);
----
